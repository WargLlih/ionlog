package rotationengine

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

const logFilePattern = "autogenerated-%s.log"

// getFileDate gets the date from the log file name.
// It returns the date and an error if the date couldn't be parsed.
func (r *rotationEngine) getFileDate(file string) (time.Time, error) {
	dateStr := strings.TrimPrefix(strings.TrimSuffix(file, ".log"), "autogenerated-")
	return time.Parse(time.DateOnly, dateStr)
}

// getAllfiles gets all the files in the folder.
// It returns a list of filenames and an error if it couldn't read the folder.
func (r *rotationEngine) getAllfiles() ([]string, error) {
	files, err := r.ReadDir(r.folder)
	if err != nil {
		return nil, err
	}

	filePattern := regexp.MustCompile(`autogenerated-\d{4}-\d{2}-\d{2}.log`)

	var filenames = make([]string, 0, len(files))
	for _, file := range files {
		if file.IsDir() {
			continue
		}

		if !filePattern.MatchString(file.Name()) {
			fmt.Fprintf(os.Stderr, "file: %s is not a valid log file. Skipping.\n", file.Name())
			continue
		}

		filenames = append(filenames, file.Name())
	}

	return filenames, nil
}

// getMostRecentLogFile gets the most recent log file from the list of files.
// It returns the most recent log filename and an error if no log file was found.
func (r *rotationEngine) getMostRecentLogFile() (string, error) {
	var mostRecent string
	var latestTime time.Time

	files, err := r.getAllfiles()
	if err != nil {
		return "", err
	}

	for _, file := range files {
		fileTime, err := r.getFileDate(file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get file date for file: %s. Skipping.\n", file)
			continue
		}

		if fileTime.After(latestTime) {
			latestTime = fileTime
			mostRecent = file
		}
	}

	if mostRecent == "" {
		return "", ErrNoLogFileFound
	}

	return mostRecent, nil
}

// createNewFile creates a new log file in the specified folder.
func (r *rotationEngine) createNewFile() {
	_, err := r.ReadDir(r.folder)
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		return
	}

	filename := fmt.Sprintf(logFilePattern, time.Now().Format(time.DateOnly))
	filePath := filepath.Join(r.folder, filename)

	f, err := r.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0644)
	if err != nil {
		fmt.Fprintln(os.Stderr, err.Error())
		return
	}

	r.setLogFile(f)
}

// assertFolder checks if the folder exists and creates it if it does not,
// it returns an error if the folder could not be created, or if it could not be checked.
func (r *rotationEngine) assertFolder() error {
	_, err := r.Stat(r.folder)
	if err == nil {
		return nil
	}

	if errors.Is(err, os.ErrNotExist) {
		if err := r.Mkdir(r.folder, 0755); err != nil {
			return err
		}
		return nil
	}

	return err // some other error
}

// checkRotation checks if the log file needs to be rotated based on the rotation type.
// It returns true if the log file needs to be rotated and false if it doesn't.
func (r *rotationEngine) checkRotation(fileDate time.Time) bool {
	now := time.Now()
	y, m, d := now.Date()
	_, w := now.UTC().ISOWeek()

	switch r.rotation {
	case Daily:
		return fileDate.Year() != y || fileDate.Month() != m || fileDate.Day() != d
	case Weekly:
		// Warning: Read the ISOWeek() documentation to check any inconsistencies
		// in the end of a year or the beginning of a new year.
		_, fileW := fileDate.UTC().ISOWeek()
		return fileDate.Year() != y || fileW != w
	case Monthly:
		return fileDate.Year() != y || fileDate.Month() != m
	default:
		fmt.Fprint(os.Stderr, "rotation value is invalid\n")
		return false
	}
}

func (r *rotationEngine) getOldestLogFile() (string, error) {
	var oldestFile string
	var oldestTime = time.Now()

	files, err := r.getAllfiles()
	if err != nil {
		return "", err
	}

	for _, file := range files {
		fileTime, err := r.getFileDate(file)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to get file date for file: %s. Skipping.\n", file)
			continue
		}

		if fileTime.Before(oldestTime) {
			oldestTime = fileTime
			oldestFile = file
		}
	}

	if oldestFile == "" {
		return "", ErrNoLogFileFound
	}

	return oldestFile, nil
}

func (r *rotationEngine) getFolderSize() (uint, error) {
	var size int64
	err := filepath.Walk(r.folder, func(_ string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		if !info.IsDir() {
			size += info.Size()
		}
		return nil
	})
	return uint(size), err
}
